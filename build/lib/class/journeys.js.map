{
  "version": 3,
  "sources": ["../../../src/lib/class/journeys.ts"],
  "sourcesContent": ["import type * as Hafas from 'hafas-client';\nimport type { TTAdapter } from '../../main';\nimport { BaseClass } from '../tools/library';\nimport { defaultJourneyOpt } from '../types/types';\n\nexport class JourneysRequest extends BaseClass {\n    constructor(adapter: TTAdapter) {\n        super(adapter);\n        this.log.setLogPrefix('routeReq');\n    }\n    /**\n     *  Ruft Abfahrten f\u00FCr eine gegebene stationId ab und schreibt sie in die States.\n     *\n     * @param from     Die Startstation.\n     * @param to       Die Zielstation.\n     * @param service      Der Service f\u00FCr die Abfrage.\n     * @param options      Zus\u00E4tzliche Optionen f\u00FCr die Abfrage.\n     * @returns             true bei Erfolg, sonst false.\n     */\n    public async getJourneys(\n        from: string,\n        to: string,\n        service: any,\n        options: Hafas.JourneysOptions = {},\n    ): Promise<boolean> {\n        try {\n            if (!from || !to) {\n                throw new Error('Keine Start- oder Zielstation \u00FCbergeben');\n            }\n            const mergedOptions = { ...defaultJourneyOpt, ...options };\n            // Antwort von HAFAS als vollst\u00E4ndiger Typ\n            const response = await service.getJourneys(from, to, mergedOptions);\n            // Vollst\u00E4ndiges JSON f\u00FCr Debugging\n            this.adapter.log.debug(JSON.stringify(response, null, 1));\n            // Schreibe die Abfahrten in die States\n            //await this.writeDepartureStates(stationId, response.departures, products);\n            return true;\n        } catch (error) {\n            this.log.error(\n                `Fehler bei der Abfrage der Abfahrten f\u00FCr Station ${from} nach ${to}: ${(error as Error).message}`,\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Filtert Abfahrten nach den gew\u00E4hlten Produkten.\n     * Es werden nur Abfahrten zur\u00FCckgegeben, deren Produkt in den aktivierten Produkten enthalten ist.\n     *\n     * @param departures    Die zu filternden Abfahrten\n     * @param products      Die aktivierten Produkte (true = erlaubt)\n     * @returns             Gefilterte Abfahrten\n     */\n    /* filterByProducts(departures: readonly Hafas.Alternative[], products: Partial<Products>): Hafas.Alternative[] {\n        // Erstelle eine Liste der aktivierten Produktnamen\n        const enabledProducts = Object.entries(products)\n            .filter(([_, enabled]) => enabled === true)\n            .map(([productName, _]) => productName);\n\n        // Wenn keine Produkte aktiviert sind, gib alle zur\u00FCck\n        if (enabledProducts.length === 0) {\n            return [...departures];\n        }\n\n        // Filtere Abfahrten: behalte nur die, deren line.product in enabledProducts ist\n        return departures.filter(departure => {\n            const lineProduct = departure.line?.product;\n            if (!lineProduct) {\n                this.log.info2(\n                    `Abfahrt ${departure.line?.name || 'unbekannt'} Richtung ${departure.direction} gefiltert: Keine Produktinfo vorhanden`,\n                );\n                return false;\n            }\n            const isEnabled = enabledProducts.includes(lineProduct);\n            if (!isEnabled) {\n                this.log.info2(\n                    `Abfahrt ${departure.line?.name} Richtung ${departure.direction} gefiltert: Produkt \"${lineProduct}\" nicht aktiviert`,\n                );\n            }\n            return isEnabled;\n        });\n    } */\n\n    /**\n     * Schreibt die Abfahrten in die States der angegebenen Station.\n     *\n     * @param stationId     Die ID der Station, f\u00FCr die die Abfahrten geschrieben werden sollen.\n     * @param departures    Die Abfahrten, die geschrieben werden sollen.\n     * @param products      Die aktivierten Produkte (true = erlaubt)\n     */\n    /* async writeDepartureStates(\n        stationId: string,\n        departures: Hafas.Alternative[],\n        products?: Partial<Products>,\n    ): Promise<void> {\n        try {\n            if (this.adapter.config.departures) {\n                for (const departure of this.adapter.config.departures) {\n                    if (departure.id === stationId && departure.enabled === true) {\n                        // Erstelle Station\n                        await this.library.writedp(`${this.adapter.namespace}.Stations.${stationId}`, undefined, {\n                            _id: 'nicht_definieren',\n                            type: 'folder',\n                            common: {\n                                name: departures[0]?.stop?.name || 'Station',\n                            },\n                            native: {},\n                        });\n                    }\n                }\n            }\n            await this.library.writedp(\n                `${this.adapter.namespace}.Stations.${stationId}.json`,\n                JSON.stringify(departures),\n                {\n                    _id: 'nicht_definieren',\n                    type: 'state',\n                    common: {\n                        name: 'raw departures data',\n                        type: 'string',\n                        role: 'json',\n                        read: true,\n                        write: false,\n                    },\n                    native: {},\n                },\n            );\n            // Filtere nach Produkten, falls angegeben\n            const filteredDepartures = products ? this.filterByProducts(departures, products) : departures;\n            // Konvertiere zu reduzierten States\n            const departureStates: DepartureState[] = mapDeparturesToDepartureStates(filteredDepartures);\n            // Vor dem Schreiben alte States l\u00F6schen\n            await this.library.garbageColleting(`${this.adapter.namespace}.Stations.${stationId}.`, 2000);\n            // JSON in die States schreiben\n            await this.library.writeFromJson(\n                `${this.adapter.namespace}.Stations.${stationId}.`,\n                'departure',\n                genericStateObjects,\n                departureStates,\n                true,\n            );\n        } catch (err) {\n            this.log.error(`Fehler beim Schreiben der Abfahrten: ${(err as Error).message}`);\n        }\n    } */\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,qBAA0B;AAC1B,mBAAkC;AAE3B,MAAM,wBAAwB,yBAAU;AAAA,EAC3C,YAAY,SAAoB;AAC5B,UAAM,OAAO;AACb,SAAK,IAAI,aAAa,UAAU;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,YACT,MACA,IACA,SACA,UAAiC,CAAC,GAClB;AAChB,QAAI;AACA,UAAI,CAAC,QAAQ,CAAC,IAAI;AACd,cAAM,IAAI,MAAM,4CAAyC;AAAA,MAC7D;AACA,YAAM,gBAAgB,EAAE,GAAG,gCAAmB,GAAG,QAAQ;AAEzD,YAAM,WAAW,MAAM,QAAQ,YAAY,MAAM,IAAI,aAAa;AAElE,WAAK,QAAQ,IAAI,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC;AAGxD,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,WAAK,IAAI;AAAA,QACL,uDAAoD,IAAI,SAAS,EAAE,KAAM,MAAgB,OAAO;AAAA,MACpG;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsGJ;",
  "names": []
}
