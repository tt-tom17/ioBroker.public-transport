{
  "version": 3,
  "sources": ["../../../src/lib/class/journeys.ts"],
  "sourcesContent": ["import type * as Hafas from 'hafas-client';\nimport type { TTAdapter } from '../../main';\nimport { StationRequest } from '../class/station';\nimport { BaseClass } from '../tools/library';\nimport { defaultJourneyOpt } from '../types/types';\n\nexport class JourneysRequest extends BaseClass {\n    private station: StationRequest;\n    private service: any;\n\n    constructor(adapter: TTAdapter) {\n        super(adapter);\n        this.log.setLogPrefix('journeyReq');\n        this.station = new StationRequest(adapter);\n    }\n    /**\n     *  Ruft Abfahrten f\u00FCr eine gegebene stationId ab und schreibt sie in die States.\n     *\n     * @param journeyId     Die ID der Verbindung.\n     * @param from          Die Startstation.\n     * @param to            Die Zielstation.\n     * @param service       Der Service f\u00FCr die Abfrage.\n     * @param options       Zus\u00E4tzliche Optionen f\u00FCr die Abfrage.\n     * @returns             true bei Erfolg, sonst false.\n     */\n    public async getJourneys(\n        journeyId: string,\n        from: string,\n        to: string,\n        service: any,\n        options: Hafas.JourneysOptions = {},\n    ): Promise<boolean> {\n        try {\n            if (!from || !to) {\n                throw new Error(this.library.translate('msg_journeyNoFromTo'));\n            }\n            this.service = service;\n            // Zusammenf\u00FChren der Standardoptionen mit den \u00FCbergebenen Optionen\n            const mergedOptions = { ...defaultJourneyOpt, ...options };\n            // Antwort von HAFAS als vollst\u00E4ndiger Typ\n            const response: Hafas.Journeys = await this.service.getJourneys(from, to, mergedOptions);\n            // Vollst\u00E4ndiges JSON f\u00FCr Debugging\n            this.adapter.log.debug(JSON.stringify(response, null, 1));\n            // Schreibe die Verbindungen in die States\n            await this.writeJourneysStates(journeyId, response);\n            return true;\n        } catch (error) {\n            this.log.error(this.library.translate('msg_journeyQueryError ', from, to, (error as Error).message));\n            return false;\n        }\n    }\n\n    /**\n     * Filtert Abfahrten nach den gew\u00E4hlten Produkten.\n     * Es werden nur Abfahrten zur\u00FCckgegeben, deren Produkt in den aktivierten Produkten enthalten ist.\n     *\n     * @param departures    Die zu filternden Abfahrten\n     * @param products      Die aktivierten Produkte (true = erlaubt)\n     * @returns             Gefilterte Abfahrten\n     */\n    /* filterByProducts(departures: readonly Hafas.Alternative[], products: Partial<Products>): Hafas.Alternative[] {\n        // Erstelle eine Liste der aktivierten Produktnamen\n        const enabledProducts = Object.entries(products)\n            .filter(([_, enabled]) => enabled === true)\n            .map(([productName, _]) => productName);\n\n        // Wenn keine Produkte aktiviert sind, gib alle zur\u00FCck\n        if (enabledProducts.length === 0) {\n            return [...departures];\n        }\n\n        // Filtere Abfahrten: behalte nur die, deren line.product in enabledProducts ist\n        return departures.filter(departure => {\n            const lineProduct = departure.line?.product;\n            if (!lineProduct) {\n                this.log.info2(\n                    `Abfahrt ${departure.line?.name || 'unbekannt'} Richtung ${departure.direction} gefiltert: Keine Produktinfo vorhanden`,\n                );\n                return false;\n            }\n            const isEnabled = enabledProducts.includes(lineProduct);\n            if (!isEnabled) {\n                this.log.info2(\n                    `Abfahrt ${departure.line?.name} Richtung ${departure.direction} gefiltert: Produkt \"${lineProduct}\" nicht aktiviert`,\n                );\n            }\n            return isEnabled;\n        });\n    } */\n\n    /**\n     * Schreibt die Verbindungen in die States.\n     *\n     * @param journeyId     Die ID der Verbindung, f\u00FCr die die Teilstrecken/Legs geschrieben werden sollen.\n     * @param journeys      Die Verbindungen, die geschrieben werden sollen.\n     */\n    async writeJourneysStates(journeyId: string, journeys: Hafas.Journeys): Promise<void> {\n        try {\n            if (this.adapter.config.journeyConfig) {\n                for (const journey of this.adapter.config.journeyConfig) {\n                    // Erstelle Verbindungs-Ordner, falls nicht vorhanden\n                    await this.library.writedp(`${this.adapter.namespace}.Journeys.${journey.id}`, undefined, {\n                        _id: 'nicht_definieren',\n                        type: 'folder',\n                        common: {\n                            name: journey.customName,\n                            statusStates: { onlineId: `${this.adapter.namespace}.Journeys.${journey.id}.enabled` },\n                        },\n                        native: {},\n                    });\n                    await this.library.writedp(\n                        `${this.adapter.namespace}.Journeys.${journey.id}.enabled`,\n                        journey.enabled,\n                        {\n                            _id: 'nicht_definieren',\n                            type: 'state',\n                            common: {\n                                name: this.library.translate('journey_enabled'),\n                                type: 'boolean',\n                                role: 'indicator',\n                                read: true,\n                                write: false,\n                            },\n                            native: {},\n                        },\n                    );\n\n                    // Vor dem Schreiben alte States l\u00F6schen\n                    await this.library.garbageColleting(`${this.adapter.namespace}.Routes.${journeyId}.`, 2000);\n                    // JSON in die States schreiben\n                    if (journey.enabled === true && journey.id === journeyId) {\n                        // Filtere nach Produkten, falls angegeben\n                        //const filteredDepartures = products ? this.filterByProducts(departures, products) : departures;\n\n                        await this.writesBaseStates(`${this.adapter.namespace}.Journeys.${journeyId}`, journeys);\n                    }\n                }\n            }\n        } catch (err) {\n            this.log.error(this.library.translate('msg_journeyWriteError', (err as Error).message));\n        }\n    }\n\n    async writesBaseStates(basePath: string, journeys: Hafas.Journeys): Promise<void> {\n        try {\n            // Rohdaten der Verbindungen\n            await this.library.writedp(`${basePath}.json`, JSON.stringify(journeys), {\n                _id: 'nicht_definieren',\n                type: 'state',\n                common: {\n                    name: this.library.translate('raw_journeys_data'),\n                    type: 'string',\n                    role: 'json',\n                    read: true,\n                    write: false,\n                },\n                native: {},\n            });\n            // Station From/To journeys.journeys[0].legs[0].origin.id\n            const stationFromId = journeys?.journeys?.[0].legs[0].origin?.id || undefined;\n            const stationToId =\n                journeys?.journeys?.[0].legs[journeys.journeys[0].legs.length - 1].destination?.id || undefined;\n            if (stationFromId !== undefined && stationToId !== undefined) {\n                const stationFrom = await this.station.getStation(stationFromId, this.service);\n                const stationTo = await this.station.getStation(stationToId, this.service);\n                await this.station.writeStationData(`${basePath}.StationFrom`, stationFrom);\n                await this.station.writeStationData(`${basePath}.StationTo`, stationTo);\n            }\n\n            /* await this.library.writedp(`${basePath}.StationFrom`, stationFrom.name, {\n                _id: 'nicht_definieren',\n                type: 'state',\n                common: {\n                    name: this.library.translate('journey_fromStation'),\n                    type: 'string',\n                    role: 'info.name',\n                    read: true,\n                    write: false,\n                },\n                native: {},\n            });\n            await this.library.writedp(`${basePath}.StationTo`, stationTo.name, {\n                _id: 'nicht_definieren',\n                type: 'state',\n                common: {\n                    name: this.library.translate('journey_toStation'),\n                    type: 'string',\n                    role: 'info.name',\n                    read: true,\n                    write: false,\n                },\n                native: {},\n            }); */\n        } catch (err) {\n            this.log.error(this.library.translate('msg_journeyStateWriteError ', (err as Error).message));\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
